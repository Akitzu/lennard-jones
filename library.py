import numpy as np
import subprocess as sp

'''File managment and data initialization functions'''

def saveas(fname,*args):
    args = tuple(args)
    with open(fname,'w') as f:
        np.savetxt(f, np.column_stack(args))

def loadas(fname,*args):
    args = tuple(args)
    rdic = {}
    with open(fname,'r') as f:
        data = np.loadtxt(fname)
        for i in range(len(args)):
            rdic[args[i]] = data[:,i]

    return rdic

def create_init_Positions(Ncells, lat_par, N):
    # Create FCC lattice for Argon atoms

    x = np.linspace(0, lat_par*Ncells-lat_par, Ncells)
    xx, yy, zz = np.meshgrid(x, x, x)
    Ncells3 = Ncells**3
    xPos = np.reshape(xx, (Ncells3, 1))
    yPos = np.reshape(yy, (Ncells3, 1))
    zPos = np.reshape(zz, (Ncells3, 1))

    # Set of atoms at 0,0,0 in unit cell
    pos1 = np.hstack((xPos, yPos, zPos))

    # Set of atoms at 1/2,1/2,0 in unit cell
    pos2 = np.zeros((Ncells3, 3))
    pos2[:, 0] = pos1[:, 0] + lat_par/2
    pos2[:, 1] = pos1[:, 1] + lat_par/2
    pos2[:, 2] = pos1[:, 2]

    # Set of atoms at 1/2,0,1/2 in unit cell
    pos3 = np.zeros((Ncells3, 3))
    pos3[:, 0] = pos1[:, 0] + lat_par/2
    pos3[:, 1] = pos1[:, 1]
    pos3[:, 2] = pos1[:, 2] + lat_par/2

    # Set of atoms at 0,1/2,1/2 in unit cell
    pos4 = np.zeros((Ncells3, 3))
    pos4[:, 0] = pos1[:, 0]
    pos4[:, 1] = pos1[:, 1] + lat_par/2
    pos4[:, 2] = pos1[:, 2] + lat_par/2

    # Vectors for all atoms
    pos = np.vstack((pos1, pos2, pos3, pos4))

    # Random displacements
    # pos += np.random.normal(0, 0.09, (N, 3))

    return pos


def create_init_Velocities(N, T):
    # Create Maxwell-Boltzmann distribution of velocities
    # x,y,z projections are generated by Normal distribution

    mu = 0
    sigma = np.sqrt(T)

    # MW veloctties
    vel = np.random.normal(mu, sigma, (N, 3))

    # Remove center of mass velocity
    mean = np.mean(vel, axis=0)
    vel -= mean

    return vel

def dump(fname, pos, vel, PRE = 15):
    pr = ''.join(['%.',str(PRE),'E'])
    with open(fname,'w') as f:
        np.savetxt(f, pos, fmt=[pr,pr,pr])
        np.savetxt(f, vel, fmt=[pr,pr,pr])

def initfile(Ncells, lat_par, T, fname):
    N = 4*Ncells**3
    # Generate fcc structure
    initPositions = create_init_Positions(Ncells, lat_par, N)
    initVelocities = create_init_Velocities(N, T)
    dump(fname,initPositions,initVelocities)

def configFile(filename,**kwargs):
    # Create config file
    lkey = ["dt","Nsteps","method","sampling","L","Nbins","thermostat","N","T","rcutoff","input","output","precision","printoption","direct_sofk"]
    with open(filename,'w') as f:
        for key in lkey:
            f.write("%s = %s" % (key, kwargs[key]))

'''Additional functions'''

def calculate_sofk_FT(gofr, L, N, qmax=30, nqvec=300):
    sofk = np.zeros(nqvec)
    v = np.zeros(nqvec)
    k = np.zeros(nqvec)
    dq = qmax/float(nqvec-1)
    rho = N / L**3
    dr = gofr['r'][1]-gofr['r'][0]
    for ii in range(nqvec):
        k[ii] = ii*dq

    for ii in range(len(k)):
        for jj in range(len(gofr['r'])):
          phase = k[ii]*gofr['r'][jj]
          # Small sinus case
          if abs(phase) < 1e-8:
            v[jj] = gofr['r'][jj]**2 * \
                (gofr['g'][jj]-1)*(1-phase**2/6 *
                 (1-phase**2/20*(1-phase**2/42)))
            # Integrand r[g(r)-1]sin(q*r)/q
          else:
            v[jj] = gofr['r'][jj]*(gofr['g'][jj]-1)*np.sin(phase)/k[ii]

        sofk[ii] = 1 + 4*np.pi*rho*np.trapz(v, dx=dr)

    return {'s': sofk, 'k': k}

def read_pos_vel(fname,N):
    pos = np.loadtxt(fname,max_rows=int(N))
    vel = np.loadtxt(fname,skiprows=int(N))
    return pos, vel

def cmd(txt):
    sp.call(txt, shell=True)

def simulate(**kwargs):
    tmpstr = "moleculardynamics.exe configuration.in"
    for key in kwargs:
        tmpstr += " " + str(key) + "=" + str(kwargs[key])
    cmd(tmpstr)

''' Constants '''
constant = {}
constant['Na'] = 6.02214076e23                              # Avogadro number
constant['kb'] = 1.380649e-23                               # Boltzmann constant
constant['epsilon'] = 120*constant['kb']                    # Lennard-Jones potential depth (J)
constant['sig'] = 3.4e-10                                   # Lennard-Jones potential radius (m)
constant['mass'] = 39.95e-3*1.6747e-24                      # Mass of Argon atom (kg) not 39.95e-3/Na in order to follow Rahman's paper
constant['T'] = 94.4*constant['kb']/constant['epsilon']     # Temperature (LJ)
constant['rho'] = 1.374e3                                   # Density (kg/m3)
constant['N'] = 864                                         # Number of atoms
constant['Ncells'] = int(np.round(np.power(constant['N']/4,1/3)))       # Number of cells in each direction
constant['L'] = np.power(constant['N']*constant['mass']/constant['rho'],1/3)/constant['sig'] # Box length (LJ)
constant['lat_par'] = constant['L']/constant['Ncells']      # Lattice parameter (LJ)

''' Simulation dictionnary '''
sim_param = {   'dt' : 1e-14*np.sqrt(constant['epsilon']/constant['mass'])/constant['sig'], 'Nsteps': 200, 'method' : 'VV', 'sampling' : 0, 'L' : constant['L'], 'N' : constant['N'], 'rcutoff' : 2.5, 'thermostat' : 'NVE',
                'T' : constant['T'], 'Q' : 10, 'lns' : 0, 'xi' : 0, 'tau' : 0.1, 'histlength' : 25, 'Nbins' : 2000, 'input' : 'init.T94.4.dat',
                'output' : 'output', 'precision' : 15, 'printoption' : 2 }

if __name__ == "__main__":
    # Create initial positions and velocities
    initfile(constant['Ncells'], constant['lat_par'], constant['T'], 'init.T94.4.dat')